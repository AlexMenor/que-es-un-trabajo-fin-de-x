---
title: "Cómo hacer un TFG/TFM en informática"
author: "JJ Merelo"
date: "1/9/2020"
output: html_document
bibliography: TF.bib
---

# Motivación

Tanto en los tribunales de trabajos fin de grado o máster (TFG/TFM, a partir de ahora sólo TF) en los que he participado me encuentro repitiendo, una y otra vez, las mismas reglas sobre lo que son o no son tanto los trabajos en sí, como la tutorización, como las presentaciones. El trasfondo es que, realmente, parece que nadie tiene claro lo que es o lo que debe de ser. En la mayor parte de los casos es irrelevante: los tribunales son soberanos, y la nota que va a obtener tiene poca relación no sólo con el trabajo realizado o su calidad, sino también con TFs de similar nivel corregidos en otros tribunales.

En todo caso, la nota obtenida es, en la mayor parte de los casos, irrelevante. Un TF es una asignatura, y cómo tal debería servir para que el estudiante aprenda; si, como debería ser, el trabajo es liberado [@porqueliberar], es un muestrario de las técnicas y habilidades que el estudiante ha sido capaz de desarrollar a lo largo del grado.

> Dejemos de lado si ha sido capaz de desarrollarlas *en* él o *a pesar de* o *aparte de* él. Si es muestrario de habilidades, de dónde procedan esas habilidades es totalmente secundario.

Por eso voy a tratar de dar una serie de reglas para poder aprovechar, efectivamente, 
este grado para crecer en la ingeniería que se ha elegido y convertirse en mejor profesional. Dirigido principalmente al estudiante, pero también a quién le toque ser tutor o tutora de este tipo de trabajos.

En todo esto, soy totalmente consciente de que, en la mayor parte de los casos, un TF es un trámite molesto que necesitas para poder acceder a un grado que necesitas, sobre todo, por el título que conlleva, no por los conocimientos que te impartan. Muchos estudiantes están ya trabajando a tiempo parcial o completo y sin el grado simplemente no pueden acceder a los convenios laborales o puestos mejor remunerados. El TF lo tienen que compatibilizar con este trabajo y lo que se desea es quitárselo de enmedio lo antes posible, sin que represente una gran cantidad de trabajo.

Por eso, lo que voy a contar trata de *no* aportar carga de trabajo adicional; en muchos casos incluso puede ayudar a tener el trabajo más enfocado y dirigido desde el principio, y a permitir organizarse el trabajo mejor para trabajar con regularidad y llegar al final más rápidamente y, sobre todo, con más eficiencia en las horas invertidas y también en el retorno de la inversión de esas horas. En todo caso, no es absolutista y no representa un camino zen de perfección: toma las reglas que te convengan o te parezcan más razonables, y deja el resto.

Este trabajo, además, es libre y está en un repositorio. Cópialo y adáptalo para entregarlo a tus tutorizados, o si crees que hay algún error o quieres aportar algo a esta copia, hazlo también. Encantado revisaré el PR y lo añadiré a la versión publicada, que actualizaré a continuación.

Como cualquier TF, debemos empezar por el 

## estado del arte

No he encontrado demasiadas guías prácticas sobre cómo afrontar el TF. Hay trabajos, como [@rodriguez2012como], que hacen una panorámica de qué tipo de trabajos recogen los reglamentos de TFG de diferentes universidades. El libro de García Sanz y Martínez Clares [@sanz2012guia] promete ser una guía práctica, pero es quizás demasiado genérico (y extenso) para poder usarse de forma práctica; no está mal, sin embargo, consultarlo antes de ponerse a trabajar. Alier et al. [@alier2012preguntas] proponen una estructuración del trabajo en tres hitos (lo que es un poco escaso para trabajos informáticos) y una serie de preguntas para cada uno de ellos, del estilo de "¿Existe una planificación del trabajo a realizar?". Puede ayudar sobre todo al tutor, pero desde luego no ayuda al estudiante a hacer dicha planificación o cómo enfocarla. Por último, la guía práctica de Monferrer y otros [@monferrer2012trabajo] puede ayudar a centrar el desarrollo inicial de un trabajo, pero es un poco demasiado genérica para ser de ayuda a estudiantes de informática. 

El problema, muchas veces, es que el estudiante realmente no tiene conocimientos (porque su grado no se ha molestado en impartírselo) para *tener* un proyecto y llevarlo a cabo. Así que vamos al principio, qué es un proyecto y cómo plantearlo.

## Un TF es la solución a un problema usando medios informáticos.

Es decir, en un TF, sea de "investigación" o de cualquier otro tipo (dejemos de lado los llamados "de revisión", que en general son para salir del paso y reflejan muy poco las habilidades adquiridas por el estudiante en una ingeniería), tienes que resolver un problema. El problema debe ser tan real como sea posible, y debe expresarse en términos cuantitativos si lo admite. Por ejemplo

* Saber qué personas con dispositivos móviles pasan por un lugar determinado, o por varios lugares, y qué tiempo pasan ahí.

Ese problema puede plantearse en varios contextos; por ejemplo, saber si vuelven y cuanto vuelven o contar cuantas personas hay, por temas de aforo (relacionado con el COVID19 o cualquier otra razón). En ese sentido, volvemos a hacer énfasis en que deben ser problemas *reales*, al menos lo más reales posibles. Sería bastante fatuo decir que se va a resolver el problema del COVID, sin embargo un subproblema sí se puede resolver, y por medios informáticos.

En este sentido, *no* sería un problema lo siguiente

* Construir un dispositivo que capte MACs de Bluetooth y WiFi.

Y no lo es principalmente porque no dice qué problema va a resolver. 

Saber qué problema se va a resolver es esencial. Del problema surge la motivación, pero también los casos de uso, es decir, las diferentes situaciones en las que diferentes tipos de usuarios interaccionarán con la solución propuesta para resolver, en ese caso, su problema. En el primer caso, las posibles aplicaciones o el problema que uno tenga en mente serán casos de uso, y de esa forma se tendrán que crear, adicionalmente, lógica de negocio para presentar esa información, o para almacenarla y procesarla. En el segundo caso no hay casos de uso. Se construye el dispositivo. Capta las MACs. Ya está. ¿Dónde se guardan esas MAC? ¿Se tienen que guardar o no?

En esto de puede ayudar la técnica del Design Thinking [@steinbeck2011design]. Recuerda que siempre es mejor, y va a ser para ti más interesante, que resuelvas *tu* problema que el que te lleguen con una solución ya hecha que ni siquiera se te haya ocurrido a ti. A partir de aquí, ya puedes pasar a la siguiente fase.

## Objetivos de un TF

Un TFG tiene que culminar en una memoria, que rara vez se lee alguien, pero que tiene que estar ahí; sobre todo si lo has liberado (recuerda, *debes* liberarlo) va a quedar como una parte aprovechable que permitirá, a quien continúe o use ese proyecto, entender por qué ha llegado a ese estado y qué se puede hacer para que evolucione o se adapte a un contexto determinado.

La memoria suele empezar con los objetivos; no siempre es así, pero así debería ser. El primer capítulo debe empezar por la motivación ("Se necesita un sistema de medición automática del aforo y de la duración de la estancia de una persona en un recinto cerrado"), pero a continuación, se deben experesar cuales son los objetivos del trabajo, es decir, qué parte de ese problema vamos a dejar resuelta y cuál se va a dejar como trabajo futuro.

Un sistema tal como ese puede tener muchos componentes. Por ejemplo, puede que sea un sólo local en cuyo caso la solución será relativamente fácil. Pero puede ser un local con muchas estancias; o pueden ser muchos locales separados físicamente. Los objetivos deben estar claros, porque de los objetivos saldrán los casos de uso (una vez más, los casos de uso son muy importantes) y de los casos de uso los hitos y tareas para resolverlos. Por ejemplo, puede ser el siguiente objetivo

* Crear un sistema que se pueda conectar a un sistema informático existente y que sea capaz de contar el número total de personas en un local así como tiempo de permanencia, con el sistema costando menos de 30€ en total.

Los objetivos deben ser alcanzables, y en lo posible cuantitativos. En este caso, nos hemos comprometido a que valga menos de 30€ (lo que puede excluir, por ejemplo, equipos del tipo Raspi). Pero en subobjetivos se puede ir más allá. 

* Subobjetivos
    * Debe ser capaz de contar en recintos de x metros cuadrados.
    * Debe contar el número de personas con una resolución de 5 minutos.

En el primer caso, va a ser totalmente diferente la solución dependiendo de la dimensión del recinto; el segundo nos va a dar un límite en la capacidad de procesamiento del sistema. Que en este caso es amplia, pero puede ser de 1 segundo, en cuyo caso habrá que componérselas. 

**No** será un objetivo
* Construir un dispositivo basado en una raspberry pi que capte WiFi y Bluetooth

Por varias razones. Un objetivo siempre tiene que estar en el dominio del problema, o en un contexto de negocio. Si el problema, por ejemplo, es automatizar los procesos de desarrollo de una empresa que provee soluciones de gestión de contenidos, un objetivo podrá ser "Crear configuraciones repetibles que funcionen con una sola orden" o "reducir el tiempo de despliegue de desarrollo a 5 minutos" o "Poder adaptar soluciones existentes a una nueva solución con una semana-persona". El objetivo **no será nunca**

* Desarrollar un script de ansible que instale todas las aplicaciones que usamos ahora.

Un objetivo *nunca* debe incluir una solución al problema si se alcanza el mismo; es algo que se debe de alcanzar, y justificar, durante el desarrollo de un proyecto. Y nunca debe ser una tarea cerrada. Un TF siempre debe resolver un problema (o parte del mismo), no hacer una tarea.

## El TF y la memoria

Un TF es un trabajo, claro, pero se evalúa mediante una memoria, que debemos asumir que van a leer, porque aunque es muy probable que no se lea completa, sí pueden leer (o tratar de leer) precisametne la parte que está mal escrita o la que falta; el tutor sí debe leerse al menos una parte considerable, o la estructura de la misma.

> Ojo: no se debe pretender, en general, que el tutor sela lea y corrija los puntos y comas, y menos si se presenta completa unos días antes de la presentación. En general, el tutor establecerá líneas generales u objectivos que la memoria debe cumplir (no tener faltas de ortografía, por ejemplo); quien la escriba debe asegurarse de que se cumplen.

Trabajo y memoria deben de ir unidos, en general. No suele suceder así, y esto es un error, pero lo mejor es que se considere la memoria como documentación del trabajo hecho para el TF y parte integral del mismo, no algo que hay que escribir al final para entregarlo y quitarse el tema de encima. Por eso es muy conveniente (d)escribir el trabajo según se vaya haciendo. Porque además, esas fases del trabajo corresponderán también a las diferentes secciones de una memoria.

### Introducción

En este capítulo debe ponerse la motivación, los objetivos generales, los subobjetivos, y describirse claramente el problema que se trata de resolver y todo lo que contribuya a entender el contexto. Si es parte del trabajo en la empresa, esto es lo que se debe describir, si está ya funcionando, también, si es un trabajo de investigación, por qué se ha elegido hacer ese trabajo específico de investigación. También se explicará el resto de la memoria, su estructura, e info adicional: en qué repositorio está, por ejemplo, o si los datos del trabajo se han publicado en algún lugar.

### Requisitos funcionales

En un capítulo tendrán que ir todos los casos de uso. En general, todo las restricciones que hay (por el negocio al que se aplique, por ejemplo) y por supuesto los casos de uso, qué es lo que queremos que el sistema resuelva. Por supuesto, estos casos de uso tendrán que estar relacionados con los objetivos; por eso es conveniente escribir a la vez que se trabaja: podemos encontrarnos que los casos de uso van más allá (en cuyo caso habrá que modificarlos) y o más acá (en cuyo caso, también, claro). Lo más importante es que cada capítulo forma parte de una misma narrativa, y los RFs no pueden estar "en el aire", sin tener ningún tipo de relación con los objetivos. Estos casos de uso deben referirse explícitamente a los objetivos, y de hecho tienen que ser anteriores a los mismos, por lo que dentro de ellos tendrá que explicarse claramente por qué. Y la motivación puede ser implícita o explícita: un caso de uso puede haber generado un objetivo.



## References